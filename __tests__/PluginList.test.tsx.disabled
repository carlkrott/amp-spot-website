import { describe, it, expect, vi } from 'vitest';
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import PluginList from '../app/components/PluginList';
import { PluginData } from '../app/components/PluginCard';
import toast from 'react-hot-toast';

// Mock toast
vi.mock('react-hot-toast');

// Mock analytics
vi.mock('../lib/analytics', () => ({
  trackCategoryFilter: vi.fn(),
}));

// Mock fetch
global.fetch = vi.fn();

describe('PluginList Component', () => {
  const mockPlugins: PluginData[] = [
    {
      id: 1,
      name: 'EQ Plugin',
      version: '1.0.0',
      description: 'A powerful equalizer',
      category: 'equalizer',
      download_count: 1500,
      created_at: '2024-01-01T00:00:00Z',
      updated_at: '2024-01-01T00:00:00Z',
    },
    {
      id: 2,
      name: 'Compressor',
      version: '1.2.0',
      description: 'Transparent compression',
      category: 'compressor',
      download_count: 2300,
      created_at: '2024-01-02T00:00:00Z',
      updated_at: '2024-01-02T00:00:00Z',
    },
  ];

  beforeEach(() => {
    vi.clearAllMocks();
    vi.mocked(global.fetch).mockResolvedValue({
      ok: true,
      json: async () => ({ plugins: mockPlugins }),
    } as Response);
  });

  describe('Rendering', () => {
    it('should render plugin list', async () => {
      render(<PluginList />);

      await waitFor(() => {
        expect(screen.getByText('EQ Plugin')).toBeInTheDocument();
        expect(screen.getByText('Compressor')).toBeInTheDocument();
      });
    });

    it('should render category filters', async () => {
      render(<PluginList />);

      const categories = ['All', 'Amplifiers', 'Effects', 'Compressors', 'Equalizers', 'Reverbs', 'Utilities'];
      await waitFor(() => {
        categories.forEach(category => {
          expect(screen.getByText(category)).toBeInTheDocument();
        });
      });
    });

    it('should show loading state initially', () => {
      render(<PluginList />);
      expect(screen.getByText(/loading/i)).toBeInTheDocument();
    });

    it('should show empty state when no plugins found', async () => {
      vi.mocked(global.fetch).mockResolvedValueOnce({
        ok: true,
        json: async () => ({ plugins: [] }),
      } as Response);

      render(<PluginList />);

      await waitFor(() => {
        expect(screen.getByText('No plugins found')).toBeInTheDocument();
      });
    });

    it('should display error message when fetch fails', async () => {
      vi.mocked(global.fetch).mockRejectedValueOnce(new Error('Network error'));

      render(<PluginList />);

      await waitFor(() => {
        expect(screen.getByText(/error: network error/i)).toBeInTheDocument();
      });
    });
  });

  describe('Category Filtering', () => {
    it('should filter plugins by category', async () => {
      const user = userEvent.setup();
      render(<PluginList />);

      const compressorFilter = await screen.findByText('Compressors');
      await user.click(compressorFilter);

      await waitFor(() => {
        expect(global.fetch).toHaveBeenCalledWith(
          expect.stringContaining('category=compressor')
        );
      });
    });

    it('should clear filter when clicking All', async () => {
      const user = userEvent.setup();
      render(<PluginList />);

      const allFilter = await screen.findByText('All');
      await user.click(allFilter);

      await waitFor(() => {
        expect(global.fetch).toHaveBeenCalledWith(
          expect.not.stringContaining('category=')
        );
      });
    });

    it('should highlight selected category', async () => {
      const user = userEvent.setup();
      render(<PluginList />);

      const compressorFilter = await screen.findByText('Compressors');
      await user.click(compressorFilter);

      expect(compressorFilter).toHaveClass('from-[#FF8C00]', 'to-[#CC7000]');
    });
  });

  describe('Download Handling', () => {
    it('should call download API when download button clicked', async () => {
      const user = userEvent.setup();
      vi.mocked(global.fetch).mockResolvedValueOnce({
        ok: true,
        json: async () => ({ plugins: mockPlugins }),
      } as Response).mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          plugin: { download_url: 'https://example.com/plugin.vst3' },
        }),
      } as Response);

      render(<PluginList />);

      const downloadButton = await screen.findByRole('button', { name: /download.*eq plugin/i });
      await user.click(downloadButton);

      await waitFor(() => {
        expect(global.fetch).toHaveBeenCalledWith(
          '/api/plugins/1/download',
          expect.objectContaining({
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
          })
        );
      });
    });

    it('should show success toast on successful download', async () => {
      const user = userEvent.setup();
      vi.mocked(global.fetch).mockResolvedValueOnce({
        ok: true,
        json: async () => ({ plugins: mockPlugins }),
      } as Response).mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          plugin: { download_url: 'https://example.com/plugin.vst3' },
        }),
      } as Response);

      render(<PluginList />);

      const downloadButton = await screen.findByRole('button', { name: /download.*eq plugin/i });
      await user.click(downloadButton);

      await waitFor(() => {
        expect(toast.success).toHaveBeenCalledWith('Downloading EQ Plugin v1.0.0...');
      });
    });

    it('should show error toast on failed download', async () => {
      const user = userEvent.setup();
      vi.mocked(global.fetch).mockResolvedValueOnce({
        ok: true,
        json: async () => ({ plugins: mockPlugins }),
      } as Response).mockResolvedValueOnce({
        ok: false,
        json: async () => ({}),
      } as Response);

      render(<PluginList />);

      const downloadButton = await screen.findByRole('button', { name: /download.*eq plugin/i });
      await user.click(downloadButton);

      await waitFor(() => {
        expect(toast.error).toHaveBeenCalledWith('Download failed. Please try again.');
      });
    });

    it('should set downloading state while downloading', async () => {
      const user = userEvent.setup();
      vi.mocked(global.fetch).mockResolvedValueOnce({
        ok: true,
        json: async () => ({ plugins: mockPlugins }),
      } as Response).mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          plugin: { download_url: 'https://example.com/plugin.vst3' },
        }),
      } as Response);

      render(<PluginList />);

      const downloadButton = await screen.findByRole('button', { name: /download.*eq plugin/i });
      await user.click(downloadButton);

      // Button should be in loading state
      expect(downloadButton).toHaveClass('opacity-50', 'cursor-not-allowed');
    });
  });

  describe('Platform Detection', () => {
    it('should detect macOS platform', () => {
      // Mock user agent for macOS
      Object.defineProperty(navigator, 'userAgent', {
        value: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)',
        configurable: true,
      });

      render(<PluginList />);

      // Platform detection should work in download handler
      // This is tested implicitly by the download API call
    });

    it('should detect Windows platform', () => {
      Object.defineProperty(navigator, 'userAgent', {
        value: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
        configurable: true,
      });

      render(<PluginList />);
    });

    it('should detect Linux platform', () => {
      Object.defineProperty(navigator, 'userAgent', {
        value: 'Mozilla/5.0 (X11; Linux x86_64)',
        configurable: true,
      });

      render(<PluginList />);
    });
  });

  describe('Initial Category Filter', () => {
    it('should filter by initial category prop', async () => {
      render(<PluginList initialCategory="compressor" />);

      await waitFor(() => {
        expect(global.fetch).toHaveBeenCalledWith(
          expect.stringContaining('category=compressor')
        );
      });
    });

    it('should not filter when initial category is not provided', async () => {
      render(<PluginList />);

      await waitFor(() => {
        expect(global.fetch).toHaveBeenCalledWith(
          expect.not.stringContaining('category=')
        );
      });
    });
  });

  describe('Accessibility', () => {
    it('should have accessible filter buttons', async () => {
      render(<PluginList />);

      const filters = await waitFor(() => screen.getAllByRole('button'));
      expect(filters.length).toBeGreaterThan(0);
    });

    it('should have accessible download buttons', async () => {
      render(<PluginList />);

      await waitFor(() => {
        expect(screen.getByRole('button', { name: /download.*eq plugin/i })).toBeInTheDocument();
        expect(screen.getByRole('button', { name: /download.*compressor/i })).toBeInTheDocument();
      });
    });
  });
});
